## 프로젝트 구조

```
src/
├── ex00/          # 메모리 구조 & 다형성 기초
├── ex01/          # 전략 패턴 (Strategy)
├── ex02/          # 프록시 패턴 (Proxy)
├── ex03/          # 어댑터 패턴 (Adapter)
├── ex04/          # 싱글톤 패턴 (Singleton)
├── ex05/          # 템플릿 메서드 패턴 (Template Method)
├── ex06/          # 데코레이터 패턴 (Decorator)
├── ex07/          # 팩토리 패턴 (Factory)
├── ex08/          # 옵저버 패턴 (Observer)
│   ├── polling/   #   - 폴링 방식 (Pull)
│   └── push/      #   - 푸시 방식 (Push)
│       ├── pub/   #     - 발행자 (Publisher)
│       └── sub/   #     - 구독자 (Subscriber)
├── ex09/          # 위임 패턴 (Delegation)
├── ex10/          # 커맨드 + 팩토리 패턴 (Command + Factory)
└── mock/          # 목 객체 패턴 (Mock Object)
```

---

## 패턴별 개념 설명

### ex01 - 전략 패턴 (Strategy)

**목적:** 알고리즘(행위)을 캡슐화하여 런타임에 교체할 수 있게 한다.

**문제 상황:**
하나의 기능에 대해 여러 가지 방식(알고리즘)이 존재할 때, `if-else`나 `switch`로 분기 처리하면 새로운 방식이 추가될 때마다 기존 코드를 수정해야 한다. 이는 개방-폐쇄 원칙(OCP)을 위반하며, 코드가 점점 복잡해진다.

**해결 방법:**
동일한 문제를 해결하는 여러 알고리즘을 하나의 인터페이스(Strategy)로 추상화하고, 각각을 별도의 클래스(ConcreteStrategy)로 구현한다. 이 알고리즘을 사용하는 클래스(Context)는 인터페이스에만 의존하며, 생성자나 setter를 통해 런타임에 전략 객체를 교체할 수 있다.

**구조:**

```
Context ──has-a──▶ <<interface>> Strategy
                        ▲
              ┌─────────┼─────────┐
        ConcreteA   ConcreteB   ConcreteC
```

**구성 요소:**

| 요소 | 역할 |
|---|---|
| Strategy (인터페이스) | 모든 알고리즘이 구현해야 할 공통 계약을 정의한다. |
| ConcreteStrategy (구체 전략) | Strategy 인터페이스를 구현하여 실제 알고리즘 로직을 담는다. |
| Context (문맥) | Strategy 객체를 합성(has-a)으로 보유하고, 실제 작업을 전략 객체에게 위임한다. |

**동작 원리:**
1. Context는 Strategy 인터페이스 타입의 필드를 갖는다 (합성/has-a 관계).
2. 클라이언트가 Context를 생성할 때 원하는 ConcreteStrategy를 주입한다.
3. Context의 메서드가 호출되면, 내부적으로 Strategy의 메서드를 호출하여 작업을 위임한다.
4. 런타임에 setter를 통해 다른 ConcreteStrategy로 교체하면, 동일한 메서드 호출이 다른 결과를 낸다.

**핵심 특징:**
- **OCP 준수**: 새로운 알고리즘을 추가할 때 기존 Context 코드를 수정하지 않고, 새 전략 클래스만 추가하면 된다.
- **런타임 교체**: 프로그램 실행 중에 알고리즘을 동적으로 변경할 수 있다.
- **합성 활용**: 상속이 아닌 합성(has-a)을 사용하여, 알고리즘을 독립적으로 변경할 수 있다.
- **분기 제거**: `if-else`/`switch`를 다형성으로 대체하여 코드의 복잡도를 낮춘다.

**적용 사례:** 정렬 알고리즘 선택, 결제 수단 선택, 압축 방식 선택, 할인 정책 적용 등

---

### ex02 - 프록시 패턴 (Proxy)

**목적:** 실제 객체에 대한 접근을 제어하는 대리 객체를 둔다.

**문제 상황:**
객체의 생성 비용이 크거나(대용량 이미지, DB 연결 등), 접근 권한을 제어해야 하거나, 호출 전후에 로깅/캐싱 같은 부가 기능이 필요한 경우, 클라이언트 코드에 이런 로직을 직접 넣으면 코드가 복잡해지고 책임이 혼재된다.

**해결 방법:**
프록시(대리 객체)를 실제 객체와 동일한 인터페이스로 구현하여, 클라이언트가 프록시인지 실제 객체인지 구분하지 못하게 한다. 프록시가 접근 제어, 지연 초기화, 로깅 등의 부가 로직을 처리하고, 실제 작업은 내부에 보유한 실제 객체에게 위임한다.

**구조:**

```
Client ──▶ <<interface>> Subject
                 ▲
           ┌─────┴─────┐
         Proxy ──▶ RealSubject
```

**구성 요소:**

| 요소 | 역할 |
|---|---|
| Subject (인터페이스) | 프록시와 실제 객체 모두가 구현하는 공통 인터페이스. 클라이언트는 이 인터페이스에만 의존한다. |
| RealSubject (실제 객체) | 실제 비즈니스 로직을 수행하는 객체. 생성 비용이 크거나 접근 제어가 필요한 대상이다. |
| Proxy (프록시) | RealSubject와 동일한 인터페이스를 구현하며, 내부에 RealSubject 참조를 보유한다. 부가 로직(지연 초기화, 접근 제어, 캐싱 등)을 처리한 후 실제 작업은 RealSubject에게 위임한다. |

**동작 원리:**
1. 클라이언트는 Subject 인터페이스를 통해 메서드를 호출한다 (Proxy인지 RealSubject인지 모른다).
2. Proxy가 호출을 가로채어 부가 로직(권한 검사, null 체크 등)을 수행한다.
3. 필요한 경우에만 RealSubject를 생성하거나 (지연 초기화), 이미 존재하면 바로 위임한다.
4. RealSubject의 메서드를 호출하여 실제 작업을 수행하고 결과를 반환한다.

**프록시의 종류:**

| 종류 | 설명 |
|---|---|
| 가상 프록시 (Virtual Proxy) | 생성 비용이 큰 객체의 생성을 실제 사용 시점까지 지연시킨다 (Lazy Loading). |
| 보호 프록시 (Protection Proxy) | 접근 권한을 검사하여 허가된 요청만 실제 객체에 전달한다. |
| 원격 프록시 (Remote Proxy) | 다른 주소 공간(네트워크)에 있는 객체를 로컬처럼 사용할 수 있게 한다. |
| 캐싱 프록시 (Caching Proxy) | 이전 요청 결과를 캐시하여 동일 요청 시 실제 객체를 호출하지 않고 반환한다. |
| 로깅 프록시 (Logging Proxy) | 실제 객체의 메서드 호출 전후에 로그를 기록한다. |

**핵심 특징:**
- **투명성**: 클라이언트는 Subject 인터페이스만 사용하므로 프록시의 존재를 인식하지 못한다.
- **단일 책임 원칙(SRP)**: 부가 기능(접근 제어, 캐싱 등)을 실제 객체에서 분리하여 프록시가 담당한다.
- **지연 초기화**: 실제 객체가 필요한 시점까지 생성을 미루어 자원을 절약할 수 있다.

**적용 사례:** 대용량 이미지/문서의 지연 로딩, 원격 서비스 호출(RMI), 접근 권한 제어, API 호출 캐싱, 메서드 호출 로깅 등

---

### ex03 - 어댑터 패턴 (Adapter)

**목적:** 호환되지 않는 인터페이스를 가진 클래스를 함께 사용할 수 있게 변환한다.

**문제 상황:**
이미 잘 동작하는 기존 클래스(Adaptee)가 있지만, 클라이언트가 기대하는 인터페이스(Target)와 메서드 시그니처가 달라서 바로 사용할 수 없다. 기존 클래스의 코드를 수정하면 다른 곳에 영향을 줄 수 있고, 외부 라이브러리인 경우 수정 자체가 불가능하다.

**해결 방법:**
Adapter 클래스를 만들어 Target 인터페이스를 구현하되, 내부에서 Adaptee의 메서드를 호출하여 변환한다. 클라이언트는 Target 인터페이스만 사용하고, 실제 작업은 Adaptee가 수행한다. 이를 통해 기존 코드를 전혀 수정하지 않고 호환성을 확보한다.

**구조:**

```
Client ──▶ <<interface>> Target
                 ▲
              Adapter ──has-a──▶ Adaptee
```

**구성 요소:**

| 요소 | 역할 |
|---|---|
| Target (인터페이스) | 클라이언트가 기대하는 인터페이스. 클라이언트는 이 인터페이스의 메서드만 호출한다. |
| Adaptee (기존 클래스) | 이미 존재하는 클래스로, 필요한 기능은 갖추고 있지만 인터페이스가 호환되지 않는다. |
| Adapter (어댑터) | Target 인터페이스를 구현하고, 내부에 Adaptee를 합성으로 보유한다. Target의 메서드 호출을 Adaptee의 메서드 호출로 변환(번역)한다. |

**동작 원리:**
1. 클라이언트는 Target 인터페이스의 메서드를 호출한다.
2. Adapter가 해당 호출을 받아, Adaptee의 호환되지 않는 메서드로 변환하여 호출한다.
3. Adaptee가 실제 작업을 수행하고 결과를 반환한다.
4. Adapter가 필요 시 결과를 Target 형식에 맞게 변환하여 클라이언트에게 반환한다.

**어댑터의 두 가지 방식:**

| 방식 | 구현 | 특징 |
|---|---|---|
| 객체 어댑터 (Object Adapter) | Adaptee를 합성(has-a)으로 보유 | 유연하다. 런타임에 Adaptee 교체 가능. 여러 Adaptee를 동시에 감쌀 수 있다. |
| 클래스 어댑터 (Class Adapter) | Adaptee를 상속(is-a)으로 확장 | 간단하지만 다중 상속이 필요하여 Java에서는 제한적이다. Adaptee의 메서드를 직접 오버라이딩할 수 있다. |

**핵심 특징:**
- **기존 코드 무수정**: Adaptee의 코드를 변경하지 않고 호환성을 확보한다.
- **OCP 준수**: 새로운 Adaptee가 생겨도 Adapter만 추가하면 되며, 기존 클라이언트 코드를 수정하지 않는다.
- **인터페이스 변환**: 핵심은 메서드 시그니처의 변환(번역)이다. `play()` → `playVlc()`처럼 이름이 다른 메서드를 연결한다.

**프록시 패턴과의 차이점:**
프록시는 동일한 인터페이스를 사용하여 접근을 제어하는 것이 목적이고, 어댑터는 서로 다른 인터페이스를 연결하여 호환성을 확보하는 것이 목적이다.

**적용 사례:** 레거시 시스템과 신규 시스템 연동, 외부 라이브러리 인터페이스 변환, 서로 다른 데이터 형식 간의 변환, 110V ↔ 220V 전압 변환기(실세계 비유) 등

---

### ex04 - 싱글톤 패턴 (Singleton)

**목적:** 클래스의 인스턴스가 오직 하나만 존재하도록 보장하고, 전역 접근점을 제공한다.

**문제 상황:**
데이터베이스 연결, 설정 관리자, 로거 등 시스템 전체에서 하나의 인스턴스만 존재해야 하는 자원이 있다. 여러 곳에서 `new`로 인스턴스를 생성하면 자원 낭비, 상태 불일치, 충돌 등의 문제가 발생한다.

**해결 방법:**
생성자를 `private`으로 선언하여 외부에서 `new`를 사용한 인스턴스 생성을 막고, `static getInstance()` 메서드를 통해서만 유일한 인스턴스에 접근하게 한다. 최초 호출 시에만 인스턴스를 생성하고, 이후에는 기존 인스턴스를 반환한다.

**구조:**

```
Singleton
 - static instance: Singleton     ← 유일한 인스턴스 저장
 - private Singleton()            ← 외부 생성 차단
 + static getInstance(): Singleton ← 전역 접근점
```

**구성 요소:**

| 요소 | 역할 |
|---|---|
| private static instance | 클래스 내부에 유일한 인스턴스를 저장하는 정적 변수이다. |
| private 생성자 | 외부에서 `new` 키워드로 인스턴스를 생성하는 것을 원천 차단한다. |
| public static getInstance() | 유일한 인스턴스에 접근하는 전역 접근점이다. 인스턴스가 없으면 생성하고, 있으면 기존 것을 반환한다. |

**동작 원리:**
1. 클래스 외부에서 `new Singleton()`은 컴파일 에러가 발생한다 (private 생성자).
2. `Singleton.getInstance()`를 호출하면, instance가 null인지 확인한다.
3. null이면 최초 1회만 인스턴스를 생성하여 static 변수에 저장한다.
4. 이후 모든 호출에서는 이미 생성된 동일한 인스턴스를 반환한다.
5. `getInstance()`를 통해 얻은 참조는 모두 같은 객체를 가리킨다 (`==` 비교 시 true).

**멀티스레드 안전성 확보 방법:**

| 방법 | 설명 | 장단점 |
|---|---|---|
| synchronized 메서드 | `getInstance()`에 synchronized 키워드 추가 | 간단하지만, 매 호출마다 동기화 비용 발생 |
| DCL (Double-Checked Locking) | null 체크를 두 번 수행하여 동기화 범위를 최소화 | 성능 개선, volatile 키워드 필요 |
| static inner class (Holder) | 내부 정적 클래스가 인스턴스를 보유, 클래스 로딩 시점에 생성 | 지연 초기화 + 스레드 안전, 가장 권장되는 방법 |
| enum 싱글톤 | enum으로 싱글톤 선언 | 직렬화/리플렉션 안전, Joshua Bloch 권장 |

**핵심 특징:**
- **유일성 보장**: 애플리케이션 전체에서 인스턴스가 오직 1개만 존재한다.
- **전역 접근**: 어디서든 `getInstance()`로 동일한 인스턴스에 접근할 수 있다.
- **지연 초기화 (Lazy Initialization)**: 최초 호출 시에만 인스턴스를 생성하여 자원을 절약한다.
- **상태 공유**: 하나의 인스턴스이므로 모든 곳에서 동일한 상태를 공유한다.

**주의사항:**
- 전역 상태를 만들므로 과도하게 사용하면 결합도가 높아지고 테스트가 어려워진다.
- 멀티스레드 환경에서는 반드시 동기화 처리가 필요하다.

**적용 사례:** 데이터베이스 커넥션 풀, 로거(Logger), 설정 관리자(Configuration), 캐시 매니저, 스레드 풀 등

---

### ex05 - 템플릿 메서드 패턴 (Template Method)

**목적:** 알고리즘의 골격(템플릿)을 상위 클래스에서 정의하고, 세부 단계를 하위 클래스에서 구현한다.

**문제 상황:**
여러 클래스가 거의 동일한 알고리즘(순서)을 따르지만, 일부 단계만 다른 경우가 있다. 각 클래스에서 전체 알고리즘을 중복 구현하면 코드 중복이 발생하고, 공통 순서가 변경될 때 모든 클래스를 수정해야 한다.

**해결 방법:**
상위 클래스(abstract class)에서 알고리즘의 전체 실행 순서를 `final` 메서드(템플릿 메서드)로 고정하고, 각 단계 중 하위 클래스마다 달라지는 부분만 추상 메서드(hook)로 선언한다. 하위 클래스는 추상 메서드만 오버라이딩하여 자신만의 동작을 구현한다.

**구조:**

```
AbstractClass
 + templateMethod()  ← final (골격 정의, 실행 순서 고정)
 - commonStep()      ← 공통 단계 (상위 클래스에서 구현)
 # step1()           ← abstract (하위 클래스가 구현)
 # step2()           ← abstract (하위 클래스가 구현)
       ▲
 ConcreteClass
 # step1() { ... }   ← 구체적인 동작 구현
 # step2() { ... }   ← 구체적인 동작 구현
```

**구성 요소:**

| 요소 | 역할 |
|---|---|
| AbstractClass (추상 클래스) | 템플릿 메서드(final)로 알고리즘의 골격과 실행 순서를 정의한다. 공통 단계는 직접 구현하고, 가변 단계는 추상 메서드로 선언한다. |
| templateMethod() | final로 선언되어 하위 클래스가 실행 순서를 변경할 수 없다. 내부에서 공통 단계와 추상 단계를 정해진 순서로 호출한다. |
| 추상 메서드 (hook) | 하위 클래스가 반드시 구현해야 하는 가변 단계이다. protected로 선언하여 외부 노출을 방지한다. |
| ConcreteClass (구체 클래스) | 추상 메서드를 오버라이딩하여 각 단계의 구체적인 동작을 결정한다. |

**동작 원리:**
1. 클라이언트가 ConcreteClass의 templateMethod()를 호출한다.
2. 상위 클래스의 templateMethod()가 실행되며, 정해진 순서대로 각 단계를 호출한다.
3. 공통 단계는 상위 클래스에서 이미 구현된 메서드가 실행된다.
4. 추상 단계는 하위 클래스에서 오버라이딩한 메서드가 실행된다 (다형성).
5. 실행 순서는 항상 동일하지만, 각 단계의 구체적 동작은 하위 클래스에 따라 달라진다.

**핵심 특징:**
- **제어의 역전 (IoC - Inversion of Control)**: 일반적으로 하위 클래스가 상위 클래스를 호출하지만, 템플릿 메서드에서는 상위 클래스가 하위 클래스의 메서드를 호출한다. 이를 "Don't call us, we'll call you" (헐리우드 원칙)라고 한다.
- **코드 중복 제거**: 공통 알고리즘 순서를 상위 클래스에 한 번만 정의하여 중복을 제거한다.
- **실행 순서 고정**: final 메서드로 알고리즘 골격을 고정하여, 하위 클래스가 순서를 변경하는 것을 방지한다.
- **확장 용이**: 새로운 변형이 필요하면 추상 메서드만 구현하는 하위 클래스를 추가하면 된다.

**전략 패턴과의 차이점:**
전략 패턴은 알고리즘 전체를 통째로 교체하는 반면, 템플릿 메서드 패턴은 알고리즘의 골격은 유지하고 일부 단계만 변경한다. 전략 패턴은 합성(has-a), 템플릿 메서드는 상속(is-a)을 사용한다.

**적용 사례:** 음료 제조 과정(물 끓이기 → 우려내기 → 컵에 따르기 → 첨가물), 데이터 파싱 절차, 게임 AI의 턴 실행 순서, 테스트 프레임워크의 setUp/test/tearDown 등

---

### ex06 - 데코레이터 패턴 (Decorator)

**목적:** 객체에 동적으로 새로운 책임(기능)을 추가한다. 상속 대신 합성을 사용한다.

**문제 상황:**
기본 기능에 다양한 옵션을 조합해야 할 때, 상속으로 해결하면 조합의 수만큼 클래스가 기하급수적으로 늘어난다 (클래스 폭발 문제). 예를 들어 기본 커피에 우유, 시럽, 휘핑크림 등을 조합하면 `CoffeeWithMilk`, `CoffeeWithSyrup`, `CoffeeWithMilkAndSyrup` 등 무수히 많은 서브클래스가 필요하다.

**해결 방법:**
기능 확장을 상속이 아닌 합성(감싸기/wrapping)으로 해결한다. 데코레이터 클래스가 원본 객체와 동일한 인터페이스를 구현하되, 내부에 원본 객체를 보유하고 기능을 추가한다. 여러 데코레이터를 겹겹이 감싸서(체이닝) 기능을 자유롭게 조합할 수 있다.

**구조:**

```
<<interface>> Component
       ▲
 ┌─────┴──────────┐
Concrete      Decorator ──has-a──▶ Component
Component        ▲
           ┌─────┴─────┐
       DecoratorA   DecoratorB
```

**구성 요소:**

| 요소 | 역할 |
|---|---|
| Component (인터페이스) | 기본 기능을 정의하는 공통 인터페이스. 원본 객체와 데코레이터 모두 이 인터페이스를 구현한다. |
| ConcreteComponent (기본 구현) | 장식(데코레이션) 대상이 되는 원본 객체. 핵심 기능만 구현한다. |
| Decorator (추상 데코레이터) | Component 인터페이스를 구현하면서 동시에 Component를 합성(has-a)으로 보유한다. 기본적으로 감싸고 있는 객체에게 위임한다. |
| ConcreteDecorator (구체 데코레이터) | Decorator를 상속하여 감싸고 있는 객체의 기능에 새로운 기능을 추가한다. |

**동작 원리:**
1. 기본 객체(ConcreteComponent)를 생성한다.
2. 이 객체를 데코레이터로 감싼다. 데코레이터는 내부에 원본 객체를 보유한다.
3. 데코레이터의 메서드가 호출되면, 먼저 내부 객체의 메서드를 호출(위임)한 뒤 자신의 기능을 추가한다.
4. 데코레이터 위에 다른 데코레이터를 겹겹이 감쌀 수 있다 (체이닝).
5. 최종 호출은 가장 바깥 데코레이터 → 안쪽 데코레이터 → 원본 객체 순으로 전파된다.

**핵심 특징:**
- **동적 기능 추가**: 컴파일 시점이 아닌 런타임에 객체에 기능을 추가/제거할 수 있다.
- **클래스 폭발 방지**: 상속 대신 합성을 사용하므로, N개의 기능을 N개의 데코레이터로 표현하고 자유롭게 조합한다.
- **체이닝**: `DecoratorB(DecoratorA(ConcreteComponent()))` 형태로 겹겹이 감싸서 기능을 누적한다.
- **투명성**: 클라이언트는 Component 인터페이스만 사용하므로, 장식된 객체인지 원본인지 구분하지 못한다.
- **단일 책임 원칙(SRP)**: 각 데코레이터가 하나의 추가 기능만 담당하여 책임이 분리된다.

**적용 사례:** 커피 옵션 조합(우유/시럽/휘핑크림), Java I/O 스트림(BufferedReader(InputStreamReader(FileInputStream))), UI 컴포넌트에 스크롤바/테두리 추가, 로깅/인증/압축 등 기능의 동적 조합 등

---

### ex07 - 팩토리 패턴 (Factory)

**목적:** 객체 생성 로직을 별도의 팩토리에 위임하여, 클라이언트가 구체 클래스를 직접 `new`하지 않게 한다.

**문제 상황:**
클라이언트가 `new Circle()`, `new Rectangle()` 등 구체 클래스를 직접 생성하면, 클라이언트 코드가 구체 클래스에 강하게 결합된다. 새로운 타입이 추가되면 `new`를 사용하는 모든 코드를 수정해야 하고, 생성 로직이 여러 곳에 분산되어 관리가 어렵다.

**해결 방법:**
팩토리 클래스를 만들어 객체 생성을 한 곳에 집중시킨다. 클라이언트는 팩토리에게 "어떤 타입을 만들어줘"라고 요청만 하고, 팩토리가 적절한 구체 클래스의 인스턴스를 생성하여 인터페이스 타입으로 반환한다. 클라이언트는 구체 클래스의 존재 자체를 알 필요가 없다.

**구조:**

```
Client ──▶ Factory.create(type) ──▶ <<interface>> Product
                                          ▲
                                   ┌──────┼──────┐
                               ProductA  ProductB  ProductC
```

**구성 요소:**

| 요소 | 역할 |
|---|---|
| Product (인터페이스) | 팩토리가 생성할 객체들의 공통 타입. 클라이언트는 이 인터페이스에만 의존한다. |
| ConcreteProduct (구체 제품) | Product 인터페이스를 구현하는 실제 클래스들이다. |
| Factory (팩토리) | 타입 정보(문자열, enum 등)를 받아 적절한 ConcreteProduct를 생성하여 Product 타입으로 반환한다. |

**동작 원리:**
1. 클라이언트가 팩토리의 create() 메서드에 타입 정보를 전달한다.
2. 팩토리는 타입에 따라 switch/if-else로 적절한 구체 클래스를 선택하여 인스턴스를 생성한다.
3. Product 인터페이스 타입으로 반환하므로, 클라이언트는 구체 클래스를 알지 못한다.
4. 새로운 타입 추가 시 팩토리의 create() 메서드에 case만 추가하면 된다.

**팩토리 패턴의 변형:**

| 변형 | 설명 |
|---|---|
| 단순 팩토리 (Simple Factory) | 정적 메서드로 객체를 생성한다. 엄밀히는 디자인 패턴보다 관용구에 가깝다. |
| 팩토리 메서드 (Factory Method) | 상위 클래스가 객체 생성 메서드를 추상으로 선언하고, 하위 클래스가 생성할 객체의 타입을 결정한다. |
| 추상 팩토리 (Abstract Factory) | 관련 있는 객체군(예: 버튼+텍스트필드+체크박스)을 한꺼번에 생성하는 인터페이스를 제공한다. |

**핵심 특징:**
- **결합도 감소**: 클라이언트가 구체 클래스에 직접 의존하지 않고, 인터페이스에만 의존한다.
- **생성 로직 집중**: 객체 생성 코드가 팩토리 한 곳에 모이므로 관리와 변경이 용이하다.
- **OCP 부분 준수**: 새로운 타입 추가 시 팩토리만 수정하면 되지만, 팩토리 자체는 수정이 필요하다. (팩토리 메서드 패턴으로 완전한 OCP 달성 가능)

**적용 사례:** 도형 생성기, 문서 편집기의 파일 형식별 파서 생성, 게임의 캐릭터/아이템 생성, 데이터베이스 드라이버 선택 등

---

### ex08 - 옵저버 패턴 (Observer)

**목적:** 한 객체의 상태 변화를 관찰하는 다수의 객체에게 자동으로 알린다. (1:N 의존 관계)

**문제 상황:**
한 객체(주체)의 상태가 변경되었을 때 이를 알아야 하는 다른 객체(관찰자)들이 여럿 존재한다. 관찰자가 주체의 상태를 계속 확인(폴링)하면 비효율적이고, 주체가 관찰자를 직접 호출하면 강한 결합이 생겨 관찰자 추가/제거가 어렵다.

**해결 방법:**
주체(Publisher/Subject)가 관찰자(Subscriber/Observer) 목록을 관리하고, 상태 변경 시 등록된 모든 관찰자에게 자동으로 알림(notify)을 보낸다. 관찰자는 공통 인터페이스를 구현하므로, 주체는 구체적인 관찰자 타입을 알 필요 없이 인터페이스를 통해 알림을 보낸다.

**구조:**

```
Subject (Publisher)
 - observers: List<Observer>
 + subscribe(observer)      ← 구독 등록
 + unsubscribe(observer)    ← 구독 해제
 + notify()                 ← 모든 구독자에게 알림
       │
       ▼
<<interface>> Observer (Subscriber)
 + update(data)             ← 알림을 받아 처리
       ▲
 ┌─────┼─────┐
ObserverA  ObserverB
```

**구성 요소:**

| 요소 | 역할 |
|---|---|
| Subject / Publisher (주체/발행자) | 상태를 관리하고, Observer 목록을 보유한다. 상태 변경 시 등록된 모든 Observer에게 알림을 보낸다. subscribe/unsubscribe로 관찰자를 동적으로 추가/제거한다. |
| Observer / Subscriber (관찰자/구독자) | 알림을 받을 객체의 공통 인터페이스. update() 메서드를 통해 상태 변경 통지를 수신한다. |
| ConcreteObserver (구체 관찰자) | Observer 인터페이스를 구현하여, 알림을 받았을 때 각자의 방식으로 반응한다. |

#### 두 가지 알림 방식

**Push 방식 (푸시):**

| 항목 | 설명 |
|---|---|
| 동작 | 주체가 상태 변경 시 모든 구독자에게 데이터를 직접 전달하며 알린다. |
| 데이터 전달 | `update(data)` - 변경된 데이터를 인자로 전달 |
| 장점 | 구독자가 별도로 데이터를 요청할 필요 없이 즉시 받을 수 있어 효율적이다. 실시간성이 높다. |
| 단점 | 구독자가 필요 없는 데이터까지 받을 수 있다. 주체가 구독자의 요구를 미리 알아야 한다. |
| 비유 | 신문 배달 서비스 - 새 신문이 나오면 구독자에게 자동 배달 |

**Polling 방식 (폴링/Pull):**

| 항목 | 설명 |
|---|---|
| 동작 | 관찰자가 주기적으로 주체의 상태를 직접 확인(pull)한다. |
| 데이터 전달 | `subject.getState()` - 관찰자가 필요할 때 직접 가져옴 |
| 장점 | 구현이 단순하다. 관찰자가 필요한 시점에 필요한 데이터만 가져올 수 있다. |
| 단점 | 변경이 없어도 반복적으로 확인하므로 자원이 낭비된다. 변경을 즉시 감지하지 못할 수 있다 (지연 발생). |
| 비유 | 게시판 확인 - 새 글이 있는지 직접 가서 확인 |

**핵심 특징:**
- **느슨한 결합**: 주체는 Observer 인터페이스에만 의존하므로, 구체적인 관찰자 타입을 알 필요 없다.
- **1:N 관계**: 하나의 주체에 다수의 관찰자가 등록/해제될 수 있다.
- **동적 구독 관리**: 런타임에 관찰자를 자유롭게 추가(subscribe)하거나 제거(unsubscribe)할 수 있다.
- **자동 알림**: 주체의 상태가 변경되면 등록된 모든 관찰자에게 자동으로 통지된다.

**적용 사례:** 뉴스 구독 시스템, GUI 이벤트 리스너, MVC 패턴의 Model→View 통지, 주식 가격 알림, SNS 팔로우/알림, Java의 PropertyChangeListener 등

---

### ex09 - 위임 패턴 (Delegation)

**목적:** 객체가 특정 작업을 직접 수행하지 않고, 다른 객체(delegate)에게 위임한다.

**문제 상황:**
코드 재사용을 위해 상속을 사용하면, 부모 클래스에 강하게 결합되어 유연성이 떨어진다. 부모 클래스의 변경이 모든 자식에 영향을 미치고, Java처럼 단일 상속만 지원하는 언어에서는 여러 클래스의 기능을 동시에 재사용할 수 없다.

**해결 방법:**
상속(is-a) 대신 합성(has-a)을 사용한다. Delegator가 작업을 수행할 Delegate 객체를 필드로 보유하고, 자신의 메서드가 호출되면 내부적으로 Delegate의 메서드를 호출하여 작업을 맡긴다. Delegate를 인터페이스 타입으로 보유하면 런타임에 교체도 가능하다.

**구조:**

```
Delegator ──has-a──▶ <<interface>> Delegate
 + doWork()                         + doWork()
   → delegate.doWork()                 ▲
                                ┌──────┼──────┐
                           ConcreteA  ConcreteB  ConcreteC
```

**구성 요소:**

| 요소 | 역할 |
|---|---|
| Delegate (인터페이스) | 위임받을 객체의 공통 계약을 정의한다. |
| ConcreteDelegate (구체 위임자) | Delegate 인터페이스를 구현하여 실제 작업을 수행한다. |
| Delegator (위임하는 객체) | Delegate 객체를 합성(has-a)으로 보유하고, 자신의 메서드 내에서 Delegate의 메서드를 호출하여 작업을 위임한다. |

**동작 원리:**
1. Delegator가 생성될 때 Delegate 인터페이스를 구현한 구체 객체를 주입받는다.
2. 클라이언트가 Delegator의 메서드를 호출한다.
3. Delegator는 직접 작업을 수행하지 않고, 내부에 보유한 Delegate의 메서드를 호출하여 위임한다.
4. setter를 통해 런타임에 Delegate를 다른 구체 객체로 교체할 수 있다.
5. 교체 후 동일한 메서드 호출이 다른 Delegate의 동작을 실행한다.

**핵심 특징:**
- **합성(has-a) 활용**: 상속의 강한 결합 없이 다른 객체의 기능을 재사용한다.
- **런타임 교체**: 위임 대상을 실행 중에 동적으로 변경할 수 있어 유연성이 높다.
- **다른 패턴의 기반 원리**: 전략 패턴, 프록시 패턴, 데코레이터 패턴 등 많은 디자인 패턴이 위임을 기반으로 한다.
- **단일 상속 제약 극복**: 합성을 통해 여러 객체의 기능을 동시에 활용할 수 있다.

**전략 패턴과의 관계:**
전략 패턴은 위임 패턴의 특수한 형태이다. 전략 패턴은 "알고리즘 교체"라는 구체적인 목적을 가지지만, 위임 패턴은 "작업을 다른 객체에게 맡긴다"는 더 일반적이고 근본적인 원리이다.

**적용 사례:** 출력 방식 위임(콘솔/파일/네트워크), 이벤트 처리 위임, iOS의 Delegate 패턴(UITableViewDelegate), 합성을 통한 코드 재사용 전반 등

---

### ex10 - 커맨드 + 팩토리 패턴 (Command + Factory)

**목적:** 요청(명령)을 객체로 캡슐화하고, 팩토리가 적절한 커맨드 객체를 생성한다.

**문제 상황:**
기능을 직접 메서드 호출로 실행하면, 실행 취소(Undo), 실행 이력 기록, 명령 큐잉, 매크로(여러 명령을 묶어 실행) 등의 부가 기능을 구현하기 어렵다. 또한 클라이언트가 구체적인 명령 클래스를 직접 생성(`new`)하면 결합도가 높아진다.

**해결 방법:**
**커맨드 패턴**으로 실행할 작업을 객체(Command)로 캡슐화하여 execute()/undo() 메서드를 통해 실행과 취소를 표준화한다. **팩토리 패턴**을 결합하여 커맨드 객체 생성을 팩토리에 위임함으로써, 클라이언트가 구체 커맨드 클래스를 알 필요 없게 한다.

**구조:**

```
Client ──▶ CommandFactory.create(type) ──▶ <<interface>> Command
                                                + execute()
                                                + undo()
                                                   ▲
                                          ┌────────┼────────┐
                                     CommandA            CommandB
                                       │                    │
                                       ▼                    ▼
                                  ReceiverA            ReceiverB
```

**구성 요소:**

| 요소 | 역할 |
|---|---|
| Command (인터페이스) | 모든 명령의 공통 계약. `execute()`로 실행, `undo()`로 취소를 정의한다. |
| ConcreteCommand (구체 커맨드) | Command 인터페이스를 구현하여 특정 요청을 객체로 캡슐화한다. 내부에 Receiver를 보유하고, execute()에서 Receiver의 메서드를 호출한다. |
| Receiver (수신자) | 실제 비즈니스 로직을 수행하는 객체. Command는 Receiver에게 작업을 위임한다. |
| Invoker (호출자) | Command를 실행하고 이력을 관리하는 객체. Command 인터페이스에만 의존하여 구체 명령을 모른다. 실행 이력을 저장하여 Undo를 지원한다. |
| CommandFactory (팩토리) | 타입 문자열을 받아 적절한 ConcreteCommand를 생성한다. 내부에 Receiver들을 보유하고 Command 생성 시 주입한다. |

**동작 원리:**
1. 클라이언트가 CommandFactory에 타입 문자열을 전달하여 Command 객체를 요청한다.
2. 팩토리가 적절한 ConcreteCommand를 생성하고, 필요한 Receiver를 주입하여 반환한다.
3. 클라이언트가 Command를 Invoker에게 전달한다.
4. Invoker가 `cmd.execute()`를 호출하면, ConcreteCommand가 Receiver의 메서드를 호출하여 실제 작업이 수행된다.
5. Invoker는 실행된 Command를 이력(history)에 저장한다.
6. Undo 요청 시, 이력에서 마지막 Command를 꺼내 `cmd.undo()`를 호출하여 반대 동작을 수행한다.

**커맨드 패턴이 가능하게 하는 것:**

| 기능 | 설명 |
|---|---|
| 매개변수화 | 어떤 Command든 Invoker에 전달할 수 있다. Invoker는 구체 타입을 모른다. |
| 실행 취소 (Undo) | Command 객체에 undo() 메서드를 정의하여 실행의 반대 동작을 수행한다. 이력을 역순으로 순회하면 다단계 Undo가 가능하다. |
| 큐잉/스케줄링 | Command 객체를 큐에 넣어 순차 실행하거나, 특정 시점에 예약 실행할 수 있다. |
| 로깅/재실행 | 실행된 Command를 로그에 기록하고, 시스템 복구 시 로그를 재실행하여 상태를 복원할 수 있다. |
| 매크로 | 여러 Command를 리스트에 담아 한 번에 실행하는 복합 명령(Macro Command)을 만들 수 있다. |

**팩토리 패턴 결합의 이점:**
- 클라이언트가 `new LightOnCommand(light)`처럼 구체 클래스를 직접 생성하지 않아도 된다.
- `factory.create("light_on")`으로 요청만 하면, 팩토리가 적절한 Receiver 주입까지 담당한다.
- 새로운 Command 추가 시 팩토리에 case만 추가하면 되어 확장이 용이하다.

**핵심 특징:**
- **요청의 객체화**: 메서드 호출을 일급 객체(first-class object)로 만들어, 저장/전달/큐잉/취소가 가능해진다.
- **발신자-수신자 분리**: Invoker(발신자)는 Command 인터페이스만 알고, Receiver(수신자)는 ConcreteCommand만 안다. 둘 사이에 직접적인 의존이 없다.
- **이력 관리 + Undo**: 실행된 명령을 이력에 저장하고 역순으로 undo()를 호출하여 다단계 실행 취소를 구현한다.

**적용 사례:** 텍스트 에디터의 Undo/Redo, GUI 버튼 클릭 처리, 리모컨의 버튼 매핑, 트랜잭션 롤백, 작업 큐/스케줄러, 매크로 녹화/재생 등

---

### mock - 목 객체 패턴 (Mock Object)

**목적:** 테스트 시 실제 의존 객체를 가짜(Mock) 객체로 대체하여 단위 테스트를 격리한다.

**문제 상황:**
테스트 대상 클래스가 외부 시스템(데이터베이스, 네트워크, 파일 시스템 등)에 의존할 때, 이 외부 시스템이 느리거나, 비용이 들거나, 환경에 따라 결과가 달라지거나, 아직 구현되지 않았을 수 있다. 이런 상태에서 단위 테스트를 작성하면 테스트가 불안정하고 느려진다.

**해결 방법:**
실제 의존 객체와 동일한 인터페이스를 구현하는 가짜(Mock) 객체를 만든다. 테스트 시 의존성 주입(DI)을 통해 실제 객체 대신 Mock 객체를 주입하면, 외부 시스템 없이도 테스트 대상의 로직만 격리하여 검증할 수 있다.

**구조:**

```
[테스트 코드] ──▶ [테스트 대상] ──▶ <<interface>> Dependency
                                          ▲
                                    ┌─────┴─────┐
                               RealImpl     MockImpl (테스트용)
```

**구성 요소:**

| 요소 | 역할 |
|---|---|
| Dependency (인터페이스) | 실제 구현과 Mock 구현 모두가 따르는 공통 계약. 테스트 대상은 이 인터페이스에만 의존한다. |
| RealImpl (실제 구현) | 프로덕션 환경에서 사용되는 실제 구현체. DB 접근, 네트워크 통신 등 외부 시스템과 상호작용한다. |
| MockImpl (Mock 구현) | 테스트 환경에서 사용되는 가짜 구현체. 외부 시스템 없이 미리 정해진 값을 반환하고, 호출 여부를 기록한다. |
| 테스트 대상 (SUT) | Dependency 인터페이스에 의존하는 클래스. 의존성 주입(DI)을 통해 실제/Mock을 교체할 수 있다. |

**테스트 더블의 종류:**

| 종류 | 역할 | 설명 |
|---|---|---|
| Dummy | 전달만 되고 사용되지 않음 | 메서드 시그니처를 맞추기 위해 전달하지만, 실제로 호출되지 않는 객체. |
| Stub | 미리 정한 값을 반환 | 특정 입력에 대해 미리 정해둔 결과를 반환한다. 테스트 환경을 원하는 상태로 설정하는 데 사용한다. |
| Spy | 호출 정보를 기록 | Stub의 기능에 추가로, 메서드 호출 횟수, 전달된 인자 등을 기록하여 나중에 검증할 수 있다. |
| Mock | 호출 기대값을 검증 | 어떤 메서드가, 몇 번, 어떤 인자로 호출되어야 하는지 기대값을 설정하고, 테스트 후 기대값과 실제 호출을 비교하여 검증한다. |
| Fake | 실제와 유사한 간소화된 구현 | 실제 동작과 비슷하지만 프로덕션에 적합하지 않은 간단한 구현. 예: 인메모리 DB, 로컬 파일 기반 저장소. |

**동작 원리:**
1. 테스트 대상 클래스는 의존성을 생성자나 setter를 통해 주입받도록 설계한다 (DI).
2. 테스트 코드에서 Mock 객체를 생성하고, 필요한 반환값을 미리 설정한다 (Stubbing).
3. 테스트 대상 클래스에 Mock 객체를 주입한다.
4. 테스트 대상의 메서드를 호출하면, 내부적으로 Mock의 메서드가 호출된다.
5. Mock은 실제 외부 시스템 대신 미리 설정된 값을 반환하고, 호출 정보를 기록한다.
6. 테스트 코드에서 반환값 검증(Stub 검증)과 호출 여부 검증(Mock 검증)을 수행한다.

**Mock 테스트의 두 가지 핵심 기법:**

| 기법 | 설명 |
|---|---|
| Stubbing (스터빙) | 테스트 전에 Mock의 반환값을 미리 설정한다. "이 메서드가 호출되면 이 값을 반환하라." 테스트 환경을 원하는 상태로 만드는 준비(Arrange) 단계이다. |
| Verification (검증) | 테스트 후에 Mock의 메서드가 올바르게 호출되었는지 확인한다. "이 메서드가 호출되었는가? 올바른 인자로 호출되었는가? 몇 번 호출되었는가?" 결과를 확인하는 단언(Assert) 단계이다. |

**핵심 특징:**
- **테스트 격리**: 외부 시스템(DB, 네트워크 등)에 의존하지 않으므로, 테스트 대상의 로직만 순수하게 검증할 수 있다.
- **테스트 속도 향상**: 실제 DB 접속, 네트워크 통신 없이 메모리 내에서 즉시 실행된다.
- **테스트 안정성**: 외부 환경(DB 상태, 네트워크 상태)에 영향받지 않아 항상 동일한 결과를 보장한다.
- **의존성 주입(DI) 필수**: 테스트 대상이 의존성을 주입받을 수 있어야 Mock으로 교체할 수 있다. 이는 자연스럽게 좋은 설계(인터페이스 의존, 느슨한 결합)를 유도한다.

**적용 사례:** 데이터베이스 접근 로직 테스트, 외부 API 호출 로직 테스트, 이메일/SMS 발송 로직 테스트, 파일 시스템 접근 테스트, 아직 구현되지 않은 모듈에 의존하는 코드의 선행 테스트 등
